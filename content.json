{"pages":[{"title":"","text":"简介: 喜欢搞事情的年轻人 姓名：black_chen(我是不会暴漏我的真实姓名的) 年龄：大好青年 爱好：王者农药、、、游山玩水，电子设备… 联系我：QQ. 756319278 weChat. black_listen 放一首诗 我说你是人间的四月天； 笑响点亮了四面风；轻灵 在春的光艳中交舞着变。 你是四月早天里的云烟， 黄昏吹着风的软，星子在 无意中闪，细雨点洒在花前。 那轻，那娉婷你是，鲜妍 百花的冠冕你戴着，你是 天真，庄严，你是夜夜的月圆。 雪化后那篇鹅黄，你象；新鲜 初放芽的绿，你是；柔嫩喜悦 水光浮动着你梦期待中白莲。 你是一树一树的花开，是燕 在梁间呢喃，——你是爱，是暖， 是希望，你是人间的四月天！ Something wrong with this article? Click here to submit your revision. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"Flex布局","text":"网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。本文主要介绍了使用display: flex可以进行的一些布局。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 Flex布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。 123.box { display: flex} 行内元素也可以使用Flex布局 123.box { display: inline-flex} Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box{ display: -webkit-flex; /* Safari */ display: flex;} 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse;} 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 示例：flex-direction flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box{ flex-wrap: nowrap | wrap | wrap-reverse;} 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 示例：flex-wrap flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} 示例：flex-flow justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 示例：justify-content align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 示例：align-items align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 示例：align-content 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item { order: &lt;integer&gt;;} 示例：order flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 示例：flex-grow flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 示例：flex-shrink flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 示例：flex-basis flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 示例：flex align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 示例：align-self 参照：原文 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Css/flex%E5%B8%83%E5%B1%80/"},{"title":"整理自己常用的vscode插件集合","text":"整理了自己所用的vscode插件 BasicAuto Close Tag 自动闭合HTML标签 Auto Import 自动导入 Beautify css/sass/scss/less 美化样式 Bracket Pair Colorizer 一个可定制的扩展，用于为匹配的括号上色 Chinese (Simplified) Language Pack for Visual Studio Code 中文语言包 Color Highlight 颜色值在代码中高亮显示 Color Info CSS拾色器 Color Picker 拾色器 cssrem 一个CSS值转REM的VSCode插件 CSS Navigation 查找CSS CSS Peek Dart Debugger fro Chrome在Chrome浏览器或任何其他支持Chrome调试器协议的目标中调试JavaScript代码。 Easy LESS 保存时自动编译到CSS Git History 查看git log Eslint Flutter gitignore 忽略文件 用于git提交时 GitLens-Git supercharged 显示文件最近的commit和作者，显示当前行commit信息 Google Translate Highlight Matching Tag HTML Snippets html代码提示 Import Cost 查看导入插件的大小 Image preview Inno Setup 启动Inno程序 JavaScript (ES6) code snippets ES6语法代码段 jsdoc JSON to Ts language-stylus Stylus语法高亮和提示 npm 运行npm命令 Path Installisense Prettier - Code formatter Preview on Web Server 在web服务器上预览网页 Python Sass sass语法高亮显示 Terminal 一个终端工具 TODO Highlight 凸显TODO关键字… TSLint TS语法检查 Vetur 目前比较好的Vue语法高亮 vue 语法高亮显示 Vue 2 Snippets 这个插件基于最新的 Vue 2 的 API 添加了Code Snippets（一些快捷方式）。 Deno vscode对deno的支持 Swig Swig语法支持 Theme🎨background 为vscode增加一个可爱的背景 Output Colorizer Polacode Power Mode Ayu Community Material Theme Dracula Official Flat UI Github Plus Theme Material Icon Theme Meterial Theme Material Theme Icons Noctis One Dark Pro Panda Theme SynthWave ‘84 🚣掘金 可在vscode中使用掘金 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/%E6%95%B4%E7%90%86%E8%87%AA%E5%B7%B1%E5%B8%B8%E7%94%A8%E7%9A%84vscode%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/"},{"title":"AbortController👀","text":"AbortController接口表示一个控制器对象，允许你根据需要中止一个或多个 Web请求。你可以使用 AbortController.AbortController() 构造函数创建一个新的 AbortController 。使用AbortSignal 对象可以完成与与DOM请求的通信。 构造函数AbortController.AbortController() 创建一个新的AbortController 对象实例。 属性AbortController.signal 只读返回一个AbortSignal对象实例，它可以用来 with/abort 一个Web(网络)请求。 方法AbortController.abort()中止一个尚未完成的Web(网络)请求。这能够中止fetch 请求，任何响应Body的消费者和流。 exampleAbortController example 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Web AbortController&lt;/p&gt; &lt;div class=\"controller\"&gt; &lt;button class=\"download\"&gt;download video&lt;/button&gt; &lt;button class=\"abort\"&gt;stop download network&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const url = './sintel.mp4' const downloadBtn = document.querySelector('.download') const abortBtn = document.querySelector('.abort') let controller downloadBtn.addEventListener('click', fetchVideo) abortBtn.addEventListener('click', () =&gt; { controller.abort() console.log('stop download') }) function fetchVideo() { controller = new AbortController() const signal = controller.signal fetch(url, { signal }).then((response) =&gt; { if (response.status === 200) { return response.blob() } else { throw new Error('Failed to fetch') } }).then((vBlob) =&gt; { console.log('----download success----') console.log(vBlob) }) } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 参考MDN AbortController Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Front/abortcontroller%F0%9F%91%80/"},{"title":"Chocolatey Window设计的包管理器","text":"Chocolatey Windows设计的包管理器，有了它，你也可以 Git Bash/Shell1choco install docker Why Chocolatey 安装 Windows 7+ / Windows Server 2003+ PowerShell v2+ (minimum is v3 for install from this website due to TLS 1.2 requirement) .NET Framework 4+ (the installation will attempt to install .NET 4.0 if you do not have it installed)(minimum is 4.5 for install from this website due to TLS 1.2 requirement) 只要你的系统在Win7以上就可以了，打开开始菜单，右键以管理员身份运行PowerShell，然后粘贴以下命令 Git Bash/Shell1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) Installing Chocolatey 检查是否安装成功 Git Bash/Shell1choco 安装一个应用 以deno为例 Git Bash/Shell1choco install deno 一些命令 安装choco install deno 升级choco upgrade deno 卸载choco uninstall deno 搜索choco search deno 查看已安装的包choco list -lo Chocolatey docs Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/chocolatey-window%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/"},{"title":"commitizen规范commit","text":"在多人协作的项目中，如果Git提交说明过于混乱，是不利于代码review的。如果Git提交说明足够精准、详细，不仅有利于代码的review也有利于后期排查问题，甚至我们可以根据commit信息生成响应日志。本文主要介绍通过cz工具，以及附和Angular规范的提交说明来规范commit信息。也可以查看vuejs，他的提交说明就是根据Angular规范来的。本文示例: cz-example 配置Git Bash/Shell12npm install -g commitizennpm install @commitlint/cli @commitlint/config-conventional conventional-changelog conventional-changelog-cli cz-conventional-changelog husky -D 创建commitlint.config.js javascript123module.exports = { extends: ['@commitlint/config-conventional']} 修改package.json 点击展开代码 &gt;folded12345678910111213\"scripts\": { \"version\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git add CHANGELOG.md\"},\"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog\" }},\"husky\": { \"hooks\": { \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\" }} 提交流程 git cz Select the type of change that you’re committing feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing tests or correcting existing tests What is the scope of this change (e.g. component or file name): (press enter to skip) 填写所修改的组件、文件名。可跳过 Write a short, imperative tense description of the change 进行一个简短的描述 max 94 Provide a longer description of the change 进行一个详细的描述可跳过 Are there any breaking changes? 是否发生重大改变 可跳过 A BREAKING CHANGE commit requires a body. Please enter a longer description of the commit itself：重大改变的描述 git pull git push 在merge到master之前需要生成CHANGELOG，之后合并最近的两个commit即可merge 具体解释规范的Git提交说明 提供更多的历史信息，方便快速浏览 可以过滤某些commit，便于筛选代码review 可以追踪commit生成更新日志 可以关联issues Git提交说明结构Git提交说明可分为三个部分：Header、Body和Footer。 1&lt;Header&gt; &lt;Body&gt; &lt;Footer&gt; HeaderHeader部分包括三个字段type（必需）、scope（可选）和subject（必需）。 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;ja Vue源码的提交说明省略了scope。 typetype用于说明 commit 的提交性质。 值 描述 feat 新增一个功能 fix 修复一个bug docs 文档变更 style 代码格式（不影响功能，例如空格、分号等格式修正） refactor 代码重构 perf 改善性能 test 测试 build 变更项目构建或外部依赖（例如scopes：webpack、gulp、npm等） ci 更改持续集成软件的配置文件和package中的scripts命令，例如scopes：Travis、Circle等 chore 变更构建流程活辅助工具 revert 代码回退 scopescope说明commit影响的范围。scope依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。 提示：scope可以省略。 subjectsubject是commit的简短描述。 Bodycommit的详细描述，说明代码提交的详细说明。 Footer如果代码的提交是不兼容变更或关闭缺陷，则Footer必需，否则可以省略。 不兼容变更当前代码与上一个版本不兼容，则Footer以BREAKING CHANGE开头，后面是对变动的描述、以及变动的理由和迁移方法。 关闭缺陷如果当前提交是针对特定的issue，那么可以在Footer部分填写需要关闭的单个 issue 或一系列issues。 Commitizencommitizen/cz-cli是一个可以实现规范的提交说明的工具： When you commit with Commitizen, you’ll be prompted to fill out any required commit fields at commit time. No more waiting until later for a git commit hook to run and reject your commit (though that can still be helpful). No more digging through CONTRIBUTING.md to find what the preferred format is. Get instant feedback on your commit message formatting and be prompted for required fields. 提供选择的提交信息类别，快速生成提交说明。安装cz工具: Git Bash/Shell1npm install -g commitizen Commitizen适配器cz-conventional-changelog如果需要在项目中使用commitizen生成符合AngularJS规范的提交说明，初始化cz-conventional-changelog适配器： Git Bash/Shell1commitizen init cz-conventional-changelog --save --save-exact 初始化命令主要进行了3件事情 在项目中安装cz-conventional-changelog 适配器依赖 将适配器依赖保存到package.json的devDependencies字段信息 在package.json中新增config.commitizen字段信息，主要用于配置cz工具的适配器路径： json12345678\"devDependencies\": { \"cz-conventional-changelog\": \"^2.1.0\"},\"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog\" }} Commitizen日志如果使用了cz工具集，配套conventional-changelog可以快速生成开发日志： Git Bash/Shell1npm install conventional-changelog conventional-changelog-cli -D 在pacage.json中加入生成日志命令： json1\"version\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git add CHANGELOG.md\" You could follow the following workflow Make changes Commit those changes Pull all the tags Run the npm version [patch|minor|major] command Push 执行npm run version后可查看生产的日志CHANGELOG.md。 注意要使用正确的Header的type，否则生成的日志会不准确，这里只是一个示例，生成的日志不是很严格。 参考Cz工具集使用介绍 - 规范Git提交说明 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Git/commitizen%E8%A7%84%E8%8C%83commit/"},{"title":"SameSite cookies报错","text":"error message：Because a cookie’s SameSite attribute was not set or is invalid, it defaults to SameSite=Lax, which prevents the cookie from being set in a cross-site context. This behavior protects user data from accidentally leaking to third parties and cross-site request forgery. Resolve this issue by updating the attributes of the cookie:Specify SameSite=None and Secure if the cookie is intended to be set in cross-site contexts. Note that only cookies sent over HTTPS may use the Secure attribute.Specify SameSite=Strict or SameSite=Lax if the cookie should not be set by cross-site requests SameSite 是HTTP响应头 Set-Cookie 的属性之一。它允许您声明该Cookie是否仅限于第一方或者同一站点上下文。 SameSite接受三个值： Lax：Cookies允许与顶级导航一起发送，并将与第三方网站发起的GET请求一起发送。这是浏览器中的默认值。Strict：Cookies只会在第一方上下文中发送，不会与第三方网站发起的请求一起发送。None：Cookie将在所有上下文中发送，即允许跨域发送。以前 None 是默认值，但最近的浏览器版本将 Lax 作为默认值，以便对某些类型的跨站请求伪造 （CSRF） 攻击具有相当强的防御能力。使用 None 时，需在最新的浏览器版本中使用 Secure 属性。更多信息见下文。 针对常见警告的解决方法 SameSite=None 需要 Secure 如果没有设置 Secure 属性，控制台中可能会出现以下警告： Some cookies are misusing the “sameSite“ attribute, so it won’t work as expected.Cookie “myCookie” rejected because it has the “sameSite=none” attribute but is missing the “secure” attribute. 出现此警告是因为需要 SameSite=None 但未标记 Secure 的任何cookie都将被拒绝。 Set-Cookie: flavor=choco; SameSite=None 要解决此问题，必须将 Secure 属性添加到 SameSite=None cookies中。 Set-Cookie: flavor=choco; SameSite=None; Secure Secure cookie仅通过HTTPS协议加密发送到服务器。请注意，不安全站点（http:）无法使用 Secure 指令设置cookies。 没有 SameSite 属性的Cookies默认为 SameSite=Lax 最新版本的现代浏览器为cookies的 SameSite 提供了更安全的默认值，因此控制台中可能会显示以下消息： Some cookies are misusing the “sameSite“ attribute, so it won’t work as expected.Cookie “myCookie” has “sameSite” policy set to “lax” because it is missing a “sameSite” attribute, and “sameSite=lax” is the default value for this attribute. 出现警告是因为未显式指定cookie的 SameSite 属性： Set-Cookie: flavor=choco 虽然您可以依赖现代浏览器自动应用 SameSite=Lax，但您应该显式地指定它，以便清楚地传达您的意图，即要如何将 SameSite 属性应用到您的cookie。这也将改善跨浏览器的体验，因为并不是所有浏览器都默认为 Lax。 Set-Cookie: flavor=choco; SameSite=Lax 实例 点击展开代码 &gt;folded123456789RewriteEngine onRewriteBase \"/\"RewriteCond \"%{HTTP_HOST}\" \"^example\\.org$\" [NC]RewriteRule \"^(.*)\" \"https://www.example.org/index.html\" [R=301,L,QSA]RewriteRule \"^(.*)\\.ht$\" \"index.php?nav=$1 [NC,L,QSA,CO=RewriteRule;01;https://www.example.org;30/;SameSite=None;Secure]RewriteRule \"^(.*)\\.htm$\" \"index.php?nav=$1 [NC,L,QSA,CO=RewriteRule;02;https://www.example.org;30/;SameSite=None;Secure]RewriteRule \"^(.*)\\.html$\" \"index.php?nav=$1 [NC,L,QSA,CO=RewriteRule;03;https://www.example.org;30/;SameSite=None;Secure][...]RewriteRule \"^admin/(.*)\\.html$\" \"admin/index.php?nav=$1 [NC,L,QSA,CO=RewriteRule;09;https://www.example.org:30/;SameSite=Strict;Secure] 参考MDN SameSiteweb.dev SameSite 浏览器显示关闭(不推荐)地址栏输入：chrome://flags/找到SameSite by default cookies和Cookies without SameSite must be secure将上面两项设置为 Disable Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/FAQ/samesite-cookies%E6%8A%A5%E9%94%99/"},{"title":"Electron问题集合","text":"Electron6.0.0版本部分window7设备上黑屏问题解决方案，官方问题issues Electron6.0.0版本部分window7设备上黑屏问题具体解决方案，安装.NET Framework 4.7.1window修复更新 下载修复页 根据不同的win7版本下载对应的补丁安装即可 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/FAQ/electron%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"},{"title":"Electron学习笔记","text":"记录自己学习Electron所整理出来的一些学习笔记。仅为个人笔记，所以写的不好，不够清晰，只会留下当时的部分思路，作为后来有问题时的速查笔记。大部分摘自官方文档，文档太长，只挑了当时的重点记录。 webview By default the webview tag is disabled in Electron &gt;= 5. 在构造 BrowserWindow 时，需要通过设置 webviewTag webPreferences选项来启用标签 当Electron版本大于等于5，需要在BrowserWindow的实例中手动开启webviewTag标签 webview BrowserWIndow使用BrowserWindow创建一个父子窗口 示例代码123456789101112131415const { app, BrowserWindow } = require(\"electron\");const createWindow = () =&gt; { let parent = new BrowserWindow(); // parent 代表是否放置在父窗体上方 let child = new BrowserWindow({ parent }); parent.loadURL(\"https://www.google.com\"); child.loadURL(\"https://www.baidu.com\"); parent.show(); child.show();};app.on('ready', () =&gt; createWindow()) BrowserWindow Dialog 显示用于打开和保存文件、警报等的本机系统对话框 示例代码123dialog.showMessageBox(child, { message: '这是一条信息'}) Dialog Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Learning/electron%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Git操作指南","text":"整理的一些Git常用命令，以及进阶命令git rebase，从这里你可以学到基础的Git配置命令、分支管理、fetch指令、git撤销、状态查询、文档查询、文件暂存、差异比较、基本操作、git进阶之rebase 配置命令列出当前配置 Git Bash/Shell1git config --list 列出Repository配置 Git Bash/Shell1git config --local --list 列出全局配置 Git Bash/Shell1git config --global --list 列出系统配置 Git Bash/Shell1git config --system --list 配置用户名 Git Bash/Shell1git config --global user.name \"your name\" 配置用户邮箱 Git Bash/Shell1git config --global user.email \"youremail@github.com\" 分支管理查看本地分支 Git Bash/Shell1git branch 查看远程分支 Git Bash/Shell1git branch -r 查看本地和远程分支 Git Bash/Shell1git branch -a 从当前分支切换到其它分支 Git Bash/Shell1git checkout &lt;branch-name&gt; 创建并切换到新分支 Git Bash/Shell1git checkout -b &lt;branch-name&gt; 删除分支 Git Bash/Shell1git branch -d &lt;branch-name&gt; 当前分支与指定分支合并 Git Bash/Shell1git merge &lt;branch-name&gt; 查看哪些分支已经/没有合并到当前分支 Git Bash/Shell12git branch --mergedgit branch --no-merged 查看各个分支最后一个提交对应的信息 Git Bash/Shell1git branch -v 删除远程分支 Git Bash/Shell1git push origin -d &lt;branch-name&gt; 重命名分支 Git Bash/Shell1git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt; 拉取远程分支并创建本地分支 Git Bash/Shell123git checkout -b 本地分支名 origin/远程分支名orgit fetch origin &lt;branch-name&gt;:&lt;local-branch-name&gt; fetch指令将远程仓库的内容更新到本地 Git Bash/Shell1git fetch origin &lt;branch-name&gt;:&lt;local-branch-name&gt; 一般而言，这个origin是远程主机名，一般默认就是origin。 branch-name 你要拉取的分支 local-branch-name 通常而言，就是你本地新建一个新分支，将origin下的某个分支代码下载到本地分支。 将某个远程主机的更新，全部取回本地 Git Bash/Shell1git fetch &lt;远程主机名&gt; 取回特定分支 Git Bash/Shell1git fetch &lt;远程主机名&gt; &lt;分支名&gt; 将某个分支的内容取回到本地的某个分支 Git Bash/Shell1git fetch origin :&lt;local-branch-name&gt; git pull 和 git fetch的区别？ git撤销撤销工作区修改 Git Bash/Shell1git checkout-- 暂存区文件撤销(不覆盖工作区) Git Bash/Shell1git reset HEAD 版本回退 git reset –(soft|mixed|hard) &lt;HEAD~(num)&gt; | 指令 作用范围 –hard 回退全部，包括HEAD，index，working，tree –mixed 回退部分，包括HEAD，index –soft 只回退HEAD 状态查询查看状态 Git Bash/Shell1git status 查看历史操作记录 Git Bash/Shell1git reflog 查看日志 Git Bash/Shell1git log 文档查询展示Git命令大纲 Git Bash/Shell1git help (--help) 展示Git命令大纲全部列表 Git Bash/Shell1git help -a 展示具体命令说明手册 Git Bash/Shell1git help 文件暂存添加改动到stash Git Bash/Shell1git stash sava -a \"message\" 删除暂存 Git Bash/Shell1git stash drop stash@{ID} 查看stash列表 Git Bash/Shell1git stash list 删除全部缓存 Git Bash/Shell1git stash clear 恢复改动 Git Bash/Shell1git stash pop stash@{ID} 差异比较比较工作区与缓存区 Git Bash/Shell1git diff 比较缓存区与本地库最近一次commit内容 Git Bash/Shell1git diff --cached 比较工作区与本地最近一次commit内容 Git Bash/Shell1git diff HEAD 比较两个commit之间的差异 Git Bash/Shell1git diff 基本操作创建本地仓库 Git Bash/Shell1git init 链接本地仓库与远程仓库 Git Bash/Shell12git remote add originorigin默认是远端仓库别名url 可以使用https或者ssh的方式 检查配置信息 Git Bash/Shell1git config --list Git user name and email Git Bash/Shell12git config --global user.name \"yourname\"git config --global user.email \"youremail\" 生成SSH秘钥 Git Bash/Shell12ssh-keygen -t rsa -C \"youremail\"cd ~/.ssh 里面有一个文件名为id_rsa.pub, 把里面的内容复制到git库的我的SSHKEYS中 查看远端仓库信息 Git Bash/Shell1git remote -v 远端仓库重新命名 Git Bash/Shell1git remote rename old new 提交到缓存区 Git Bash/Shell12git add . 全部文件git add 指定文件 提交到本地仓库 Git Bash/Shell1git commit -m \"message\" 提交到远程仓库 Git Bash/Shell1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git 进阶之rebaseGit commits历史是如何做到如此清爽的？ Rebase场景一：如何合并多次提交记录 合并最近的n次提交记录 Git Bash/Shell1git rebase -i HEAD~n 进入vi编辑模式 pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d） 如果保存的时候，出错 JavaScript1error: cannot 'squash' without a previous commit 注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。 如果你异常退出了 vi 窗口 Git Bash/Shell1git rebase --edit-todo 这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下 Git Bash/Shell1git rebase --continue 查看结果 Git Bash/Shell1git log Rebase场景二：分支合并 我们先从 master 分支切出一个 dev 分支，进行开发： Git Bash/Shell1git checkout -b feature 这时候，你的同事完成了一次 hotfix，并合并入了 master 分支，此时 master 已经领先于你的 feature 分支了 恰巧，我们想要同步 master 分支的改动，首先想到了 merge 让我们来试试 git rebase而不是使用merge Git Bash/Shell1git rebase master 首先，git 会把 feature 分支里面的每个 commit 取消掉；其次，把上面的操作临时保存成 patch 文件，存在 .git/rebase 目录下；然后，把 feature 分支更新到最新的 master 分支；最后，把上面保存的 patch 文件应用到 feature 分支上； 从 commit 记录我们可以看出来，feature 分支是基于 hotfix 合并后的 master ，自然而然的成为了最领先的分支，而且没有 merge 的 commit 记录，是不是感觉很舒服了。 在 rebase 的过程中，也许会出现冲突 conflict。在这种情况，git 会停止 rebase 并会让你去解决冲突。在解决完冲突后，用 git add 命令去更新这些内容 Git Bash/Shell1git rebase --continue 这样 git 会继续应用余下的 patch 补丁文件。 在任何时候，我们都可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。 Git Bash/Shell1git rebase —abort 参考https://juejin.im/post/6869519303864123399 http://jartto.wang/2018/12/11/git-rebase/ https://git-scm.com/book/zh/v2/ Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Git/git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"},{"title":"JSON.stringify()","text":"JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。 语法 JSON.stringify(value[, replacer [, space]]) 参数 value将要序列化成 一个 JSON 字符串的值。 replacer | 可选如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。 space | 可选指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。 返回值一个表示给定值的JSON字符串。 特性对于 undefined、任意的函数以及 symbol 三个特殊的值分别作为对象属性的值、数组元素、单独的值时的不同返回结果。 undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 跳过（忽略）对它们进行序列化示例代码1234567891011const data = { a: \"aaa\", b: undefined, c: Symbol(\"dd\"), fn: function() { return true; }};JSON.stringify(data); // 输出：？// \"{\"a\":\"aaa\"}\" undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 将会将它们序列化为 null示例代码12345JSON.stringify([\"aaa\", undefined, function aa() { return true}, Symbol('dd')]) // 输出：？// \"[\"aaa\",null,null,null]\" undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时都会返回 undefined示例代码123456JSON.stringify(function a (){console.log('a')})// undefinedJSON.stringify(undefined)// undefinedJSON.stringify(Symbol('dd'))// undefined 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中因为null function symbol都会被忽略掉，所以必然是没有特定的顺序的 示例代码1234567891011121314151617const data = { a: \"aaa\", b: undefined, c: Symbol(\"dd\"), fn: function() { return true; }, d: \"ddd\"};JSON.stringify(data); // 输出：？// \"{\"a\":\"aaa\",\"d\":\"ddd\"}\"JSON.stringify([\"aaa\", undefined, function aa() { return true}, Symbol('dd'),\"eee\"]) // 输出：？// \"[\"aaa\",null,null,null,\"eee\"]\" 转换值如果有 toJSON() 函数，该函数返回什么值，序列化结果就是什么值，并且忽略其他属性的值。拥有toJSON函数后进行序列化会默认走toJSON 示例代码1234567JSON.stringify({ say: \"hello JSON.stringify\", toJSON: function() { return \"today i learn\"; }})// \"today i learn\" JSON.stringify() 将会正常序列化 Date 的值默认调用的是toISOString()会自动转化为国际化时间 示例代码12JSON.stringify({ now: new Date() });// \"{\"now\":\"2020-07-21T06:07:14.864Z\"}\" NaN 和 Infinity 格式的数值及 null 都会被当做 null。示例代码123456JSON.stringify(NaN)// \"null\"JSON.stringify(null)// \"null\"JSON.stringify(Infinity)// \"null\" 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。示例代码12JSON.stringify([new Number(1), new String(\"false\"), new Boolean(false)]);// \"[1,\"false\",false]\" 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。仅会序列化可枚举的属性 示例代码1234567891011// 不可枚举的属性默认会被忽略：JSON.stringify( Object.create( null, { x: { value: 'json', enumerable: false }, y: { value: 'stringify', enumerable: true } } ));// \"{\"y\":\"stringify\"}\" 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。示例代码12345678910111213141516171819202122232425// 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 const obj = { name: \"loopObj\"};const loopObj = { obj};// 对象之间形成循环引用，形成闭环obj.loopObj = loopObj;// 封装一个深拷贝的函数function deepClone(obj) { return JSON.parse(JSON.stringify(obj));}// 执行深拷贝，抛出错误deepClone(obj)/** VM44:9 Uncaught TypeError: Converting circular structure to JSON --&gt; starting at object with constructor 'Object' | property 'loopObj' -&gt; object with constructor 'Object' --- property 'obj' closes the circle at JSON.stringify (&lt;anonymous&gt;) at deepClone (&lt;anonymous&gt;:9:26) at &lt;anonymous&gt;:11:13*/ 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。示例代码1234567JSON.stringify({ [Symbol.for(\"json\")]: \"stringify\" }, function(k, v) { if (typeof k === \"symbol\") { return v; }})// undefined 如何序列化undefined function symbol示例代码12345678910111213141516171819202122232425const data = { a: \"aaa\", b: undefined, c: Symbol(\"dd\"), fn: function() { return true; }};// 不用 replacer 参数时JSON.stringify(data); // \"{\"a\":\"aaa\"}\"// 使用 replacer 参数作为函数时JSON.stringify(data, (key, value) =&gt; { switch (typeof value) { case \"undefined\": return \"undefined\"; case \"symbol\": return value.toString(); case \"function\": return value.toString(); } return value;})// \"{\"a\":\"aaa\",\"b\":\"undefined\",\"c\":\"Symbol(dd)\",\"fn\":\"function() {\\n return true;\\n }\"}\" 或者 示例代码1234567891011JSON.stringify(data, (key, value) =&gt; { switch (typeof value) { case \"undefined\": return \"undefined\"; case \"symbol\": return value.toString(); case \"function\": return value.toString(); } return value;}) TO 示例代码1JSON.stringify(data, (key, value) =&gt; (['undefined', 'symbol', 'function'].includes(typeof Value) ? String(value) : value)); 如何序列化某一项值 replacer 作为数组时，结果非常简单，数组的值就代表了将被序列化成 JSON 字符串的属性名 示例代码12345678const jsonObj = { name: \"JSON.stringify\", params: \"obj,replacer,space\"};// 只保留 params 属性的值JSON.stringify(jsonObj, [\"params\"]);// \"{\"params\":\"obj,replacer,space\"}\" 参考MDN JSON stringify 你不知道的 JSON.stringify() 的威力 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Front/json-stringify/"},{"title":"Math basic api","text":"Math 是一个内置对象，它拥有一些数学常数属性和数学函数方法。Math 不是一个函数对象。Math 用于 Number 类型。它不支持 BigInt。 与其他全局对象不同的是，Math 不是一个构造器。Math 的所有属性与方法都是静态的。引用圆周率的写法是 Math.PI，调用正余弦函数的写法是 Math.sin(x)，x 是要传入的参数。Math 的常量是使用 JavaScript 中的全精度浮点数来定义的。 常用的Math函数Math basic api example 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041let mathArr = [5, 1, 10, 3, 6, 5]// Math.min()是Js数学库中的函数没用于将所有传递的值中的最小值返回const min = Math.min(...mathArr)console.log(`最小值：Math.min(...mathArr) = ${min}`)// Math.max()将所有传递值中的最大值返回const max = Math.max(...mathArr)console.log(`最大值：Math.max(...mathArr) = ${max}`)// Math.round返回一个数字四舍五入后最接近的整数const round = Math.round(4.5)console.log(`四舍五入：Math.round(4.5) = ${round}`)// Math.sqrt()返回一个数的平方根const sqrt = Math.sqrt(4)console.log(`平方根：Math.sqrt(4) = ${sqrt}`)// Math.pow()函数返回基数(base)的指数(exponent)次幂const pow = Math.pow(2, 3)console.log(`基数的指数次幂：Math.pow(2, 3) = ${pow}`)// Math.floor()返回小于或等于一个给定数字的最大整数const floor = Math.floor(4.9)console.log(`小于给定数字的最大整数：Math.floor(4.9) = ${floor}`)// Math.random()函数返回一个浮点, 伪随机数在范围从0到小于1，也就是说，从0（包括0）往上，但是不包括1（排除1），然后你可以缩放到所需的范围。实现将初始种子选择到随机数生成算法;它不能被用户选择或重置。const random = Math.random()console.log(`随机数：Math.random() = ${random}`)// Math.cos() 返回一个数值的余弦值const cos = Math.cos(180)console.log(`余弦值：Math.cos(180) = ${cos}`)// Math.sin() 返回一个函数的正弦值const sin = Math.sin(90)console.log(`正弦值：Math.sin(90) = ${sin}`)// Math.ceil() 返回大于或等于一个更定数字的最小整数const ceil = Math.ceil(4.1)console.log(`大于或等于一个给定数字的最小整数：Math.ceil(4.1) = ${ceil}`) 更多MDN Math Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Front/math-basic-api/"},{"title":"如何自定义切换Node源✨","text":"在我们使用nodejs进行安包时，常常使用淘宝镜像 https://registry.npm.taobao.org/ ，也是是cnpm源。nodejs默认使用npm源，npm源在下载一些国外资源是速度比较慢，这个时候我们会考虑使用npm config全局配置cnpm源。但由于我们有时候会有一些package放在自己的npm私服上面，我们可能需要在npm cnpm 自己的npm源上面来回切换，这个时候我们使用npm config进行全局配置就略显麻烦了。所以我们使用nrm进行npm源的管理。 全局安装nrm Git Bash/Shell1npm install nrm -g or yarn global add nrm 一些基础命令 Git Bash/Shell123456789101112nrm -V # 查看版本nrm ls # 查看当前可选的源 * npm ----- https://registry.npmjs.org/ yarn ----- https://registry.yarnpkg.com cnpm ---- http://r.cnpmjs.org/ taobao -- https://registry.npm.taobao.org/ nj ------ https://registry.nodejitsu.com/ skimdb -- https://skimdb.npmjs.com/registrynrm add &lt;registry&gt; &lt;url&gt; [home] # 添加新源nrm del &lt;registry&gt; # 删除nrm use &lt;registry&gt; 选择你要使用的源 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E6%8D%A2node%E6%BA%90%E2%9C%A8/"},{"title":"安装多个版本的node✨","text":"nodejs是前端经常使用到的，nodejs拥有很多版本，我们一般使用官方提供的稳定版本就好了，当然，如果你想体验一些新功能 新特性 可以使用最新版本的nodejs。在我们团队的协作中，因为有package.json的存在，所以我们尽量保证团队是用的nodejs版本一致。这个时候我们就需要版本控制工具nvm了。 window下使用nvm🚗下载链接 程序安装过程中，在 Set Node.js Symlink 这一步目录设置，是待会 nvm use 存放你的 nodejs 程序的目录 Git Bash/Shell12345nvm v # 查看版本nvm install latest # 下载最新版本的nodenvm install 12.1.0 # 下载12.1.0版本的nodenvm install 12.1.0 32 # 默认64位 32位需指定nvm uninstall 12.1.0 # 卸载对应的版本 下载完成后，会在\\nvm文件下多一个v12.1.0的文件夹 Git Bash/Shell1nvm use 12.1.0 # 引入使用 Git Bash/Shell12nvm ls # 查看已安装的node版本 * 12.1.0 (Currently using 64-bit executable) Mac下使用nvm🚗Git Bash/Shell1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.0/install.sh | bash 或 Git Bash/Shell1wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.0/install.sh | bash 执行完后重启终端 Git Bash/Shell1nvm install 12.13.0 # 安装指定版本 Git Bash/Shell1nvm use 12.13.0 # 使用指定版本 文档链接 Something wrong with this article? Click here to submit your revision. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/%E5%AE%89%E8%A3%85%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84node%E2%9C%A8/"},{"title":"什么是热更新？","text":"看到浏览器热更新，我们很容易就想到的是webpack 和 webpack-dev-server。问题：热更新是保存后自动编译（Auto Compile）吗？还是自动刷新浏览器（Live Reload）？还是指HMR（Hot Module Replacement，模块热替换）？先看一下什么是浏览器的热更新。浏览器的热更新，指的是我们在本地开发的同时打开浏览器进行预览，当代码发生变化时，浏览器自动更新页面的技术。这里的自动更新，表现上又分为自动刷新整个页面，以及页面整体无刷新而只更新页面的部分内容。 本文示例代码webpack hmr example 热更新是保存后自动编译（Auto Compile）？一个简单的实现是使用webpack提供的watch 示例代码12345678module.exports = { entry: './src/index0.js', mode: 'development', watch: true}// package.json\"build:watch\": \"webpack --config webpack.config.watch.js\" 实现了保存后自动编译，但也有很多弊端，必须要刷新页面才可以看到实时的编译结果 热更新是自动刷新浏览器（Live Reload）？一个简单的实现是利用webpack-dev-server实现一个简单的 Live Reload，其原理就是建立websocket长连接 示例代码1234567891011module.exports = { entry: './src/index0.js', mode: 'development', devServer: { contentBase: './dist', open: true, }}// package.json\"dev:reload\": \"webpack-dev-server --config webpack.config.reload.js\" 这基本已经实现了我们预期的结果，但我们发现在它其实是每次自动帮我们刷新了页面，这样的话我们input框的输入内容、model框都在下一次编译后恢复初始。 热更新指的是HMR（Hot Module Replacement，模块热替换）？一个简单的实现是利用webpack-dev-server实现一个简单的 HMR，其原理是通过websocket和新增的两个请求：hot-update.json 和 hot-update.js 示例代码1234567891011121314151617module.exports = { entry: './src/index1.js', mode: 'development', devServer: { contentBase: './dist', open: true, hot: true }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }} 虽然这种方式已经可以动态更新样式，但对js的支持还是如上一种方式一样，需要刷新页面 webpack中的热更新下图是 webpackDevServer 中 HMR 的基本流程图，完整的 HMR 功能主要包含了三方面的技术： watch 示例中体现的，对本地源代码文件内容变更的监控。 instant reload 示例中体现的，浏览器网页端与本地服务器端的 Websocket 通信。 hmr 示例中体现的，也即是最核心的，模块解析与替换功能。 也就是说在这三种技术中，我们可以基于 Node.js 中提供的文件模块 fs.watch 来实现对文件和文件夹的监控，同样也可以使用 sockjs-node 或 socket.io 来实现 Websocket 的通信。而在这里，我们重点来看下第三种， webpack 中的模块解析与替换功能 webpack中的打包流程术语 module：指的是模块化编程中我们把应用程序分割成的独立功能代码块 chunk：指模块间按照引用关系组合成的代码块，一个chunk中可以包含多个module chunk group：指通过配置入口点（entry point）区分的块组，一个chunk group中可以包含多个chunk bundling：webpack打包的过程 asset/bundle：打包的产物 webpack 的打包思想可以简化为 3 点： 一切源代码文件均可通过各种 Loader 转换为 JS 模块 （module），模块之间可以互相引用。 webpack 通过入口点（entry point）递归处理各模块引用关系，最后输出为一个或多个产物包 js(bundle) 文件。 每一个入口点都是一个块组（chunk group），在不考虑分包的情况下，一个 chunk group 中只有一个 chunk，该 chunk 包含递归分析后的所有模块。每一个 chunk 都有对应的一个打包后的输出文件（asset/bundle）。 在上面的 hmr 示例中，从 entry 中的 ‘./src/index1.js’ 到打包产物的 dist/main.js，以模块的角度而言，其基本流程是： 唯一 entry 创建一个块组（chunk group）， name 为 main，包含了 ./src/index1.js 这一个模块。 在解析器中处理 ./src/index1.js 模块的代码，找到了其依赖的 ‘./style.css’，找到匹配的 loader: css-loader 和 style-loader。 首先通过 css-loader 处理，将 css-loader/dist/cjs.js!./src/style.css 模块（即把 CSS 文件内容转化为 js 可执行代码的模块，这里简称为 Content 模块）和 css-loader/dist/runtime/api.js 模块打入 chunk 中。 然后通过 style-loader 处理，将 style-loader/dist/runtime/injectStylesIntoStyleTag.js 模块 （我们这里简称为 API 模块），以及处理后的 .src/style.css 模块（作用是运行时中通过 API 模块将 Content 模块内容注入 Style 标签）导入 chunk 中。 依次类推，直到将所有依赖的模块均打入到 chunk 中，最后输出名为 main.js 的产物（我们称为 Asset 或 Bundle） 上述流程的结果我们可以在预览页面中控制台的 Sources 面板中看到，这里，我们重点看经过 style-loader 处理的 style.css 模块的代码： style-loader中的热替换代码简化一下上述控制台中看到的 style-loader 处理后的模块代码，只看其热替换相关的部分。 12345678910111213141516171819//为了清晰期间，我们将模块名称注释以及与热更新无关的逻辑省略，并将 css 内容模块路径赋值为变量 cssContentPath 以便多处引用，实际代码可从示例运行时中查看 var cssContentPath = \"./node_modules/css-loader/dist/cjs.js!./src/style.css\" var api = __webpack_require__(\"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var content = __webpack_require__(cssContentPath);... var update = api(content, options); ... module.hot.accept( cssContentPath, function(){ content = __webpack_require__(cssContentPath) ... update(content) } ) module.hot.dispose(function() { &nbsp; update()}) 从上面的代码中我们可以看到，在运行时调用 API 实现将样式注入新生成的 style 标签，并将返回函数传递给 update 变量。然后，在 module.hot.accept 方法的回调函数中执行 update(content)，在 module.hot.dispose 中执行 update()。通过查看上述 API 的代码，可以发现 update(content) 是将新的样式内容更新到原 style 标签中，而 update() 则是移除注入的 style 标签，那么这里的 module.hot 究竟是什么呢？ 模块热替换插件（HotModuleReplacementPlugin）上面的 module.hot 实际上是一个来自 webpack 的基础插件 HotModuleReplacementPlugin，该插件作为热替换功能的基础插件，其 API 方法导出到了 module.hot 的属性中。 在上面代码的两个 API 中，hot.accept 方法传入依赖模块名称和回调方法，当依赖模块发生更新时，其回调方法就会被执行，而开发者就可以在回调中实现对应的替换逻辑，即上面的用更新的样式替换原标签中的样式。另一个 hot.dispose 方法则是传入一个回调，当代码上下文的模块被移除时，其回调方法就会被执行。例如当我们在源代码中移除导入的 CSS 模块时，运行时原有的模块中的 update() 就会被执行，从而在页面移除对应的 style 标签。 module.hot 中还包含了该插件提供的其他热更新相关的 API 方法，这里就不再赘述了，感兴趣的同学可以从 官方文档中进一步了解。 通过上面的分析，我们就了解了热替换的基本原理，这也解释了为什么我们替换 index1.js 中的输出文本内容时，并没有观察到热更新，而是看到了整个页面的刷新：因为代码中并未包含对热替换插件 API 的调用，代码的解析也没有配置额外能对特定代码调用热替换 API 的 Loader。所以在最后，我们就来实现下 JS 中更新文本内容的热替换。 这也就解释了为什么我们改变js代码是刷新页面而不是直接的hmr了 js代码中的hmr示例代码123456789101112131415import { text } from './text'const div = document.createElement('div')document.body.appendChild(div)function render() { div.innerHTML = text}render()if(module.hot) { module.hot.accept('./text.js', () =&gt; { render() })} 在上面的代码中，我们将用于修改的文本单独作为一个 JS 模块，以便传入 hot.accept 方法。当文本发生变更时，可以观察到浏览器端显示最新内容的同时并未触发页面刷新，验证生效。此外， accept 方法也支持监控当前文件的变更，对应的 DOM 更新逻辑稍做调整也能达到无刷新效果，区别在于替换自身模块时示例中不可避免地需要更改 DOM 从上面的例子中我们可以看到，热替换的实现，既依赖 webpack 核心代码中 HotModuleReplacementPlugin 所提供的相关 API，也依赖在具体模块的加载器中实现相应 API 的更新替换逻辑。因此，在配置中开启 hot:true 并不意味着任何代码的变更都能实现热替换，除了示例中演示的 style-loader 外， vue-loader、 react-hot-loader 等加载器也都实现了该功能。当开发时遇到 hmr 不生效的情况时，可以优先确认对应加载器是否支持该功能，以及是否使用了正确的配置。 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F/"},{"title":"什么是Source Map","text":"在日常开发过程中，我们编写的源代码通过多重处理（编译，封装，压缩…），最后形成的产物代码，在浏览器中调试时，我们会发现代码变得面目全非，根本没办法调试。因此，我们需要一种将产物代码回溯到源代码的功能，Source Map就是实现这一功能的工具。Source Map的基本原理是，在编译过程中，在生成产物代码的同时也生成基于源代码的一份映射关系表。有了这张映射关系表，我们就可以通过 chrome 控制台中的“Enable JavaScript source map”来实现调试时的显示与定位源代码的功能。生成Source Map的方式有很多种，他们的构建速度、质量（反解代码与源代码的接近程度以及调试时行号等辅助信息的对应情况）、访问方式（在产物文件中或单独生成 source map）、文件大小都各不相同。在开发和生成环境下我们对 source map 的期望也有所不同。 在开发环境中，我们更关心构建速度、质量，以便于提升开发效率，而不关心文件大小与访问方式 在生产环境中，我们更关注的是，是否需要开启 source map，生成文件的大小和访问方式是否对页面性能造成影响，其次才是质量和构建速度。 本文示例代码webpack source map example webpack 中 source map 的预设在webpack中，通过设置 devtool 来选择 source map 的预设类型，它提供了20 多种source map 的预设。 这些预设通常包含了eval、cheap、module、inline、hidden、nosource、source-map等关键字组合。 示例代码123456789101112131415161718192021222324252627282930// TODO webpack/lib/WebpackOptionsApply.js:232if (options.devtool.includes(\"source-map\")) { const hidden = options.devtool.includes(\"hidden\"); const inline = options.devtool.includes(\"inline\"); const evalWrapped = options.devtool.includes(\"eval\"); const cheap = options.devtool.includes(\"cheap\"); const moduleMaps = options.devtool.includes(\"module\"); const noSources = options.devtool.includes(\"nosources\"); const Plugin = evalWrapped ? require(\"./EvalSourceMapDevToolPlugin\") : require(\"./SourceMapDevToolPlugin\"); new Plugin({ filename: inline ? null : options.output.sourceMapFilename, moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate, fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate, append: hidden ? false : undefined, module: moduleMaps ? true : cheap ? false : true, columns: cheap ? false : true, noSources: noSources, namespace: options.output.devtoolNamespace, }).apply(compiler);} else if (options.devtool.includes(\"eval\")) { const EvalDevToolModulePlugin = require(\"./EvalDevToolModulePlugin\"); new EvalDevToolModulePlugin({ moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate, namespace: options.output.devtoolNamespace, }).apply(compiler);} devtool 的值匹配并非精确匹配，某个关键字只要包含在赋值中即可获得匹配，例如：’foo-eval-bar’ 等同于 ‘eval’，’cheapfoo-source-map’ 等同于 ‘cheap-source-map’。 Source Map 名称关键字 false：即不开启 source map 功能，其他不符合上述规则的赋值也等价于 false。 eval：是指在编译器中使用 EvalDevToolModulePlugin 作为 source map 的处理插件。[xxx-…]source-map：根据 devtool 对应值中是否有 eval 关键字来决定使用 EvalSourceMapDevToolPlugin 或 SourceMapDevToolPlugin 作为 source map 的处理插件，其余关键字则决定传入到插件的相关字段赋值。 inline：决定是否传入插件的 filename 参数，作用是决定单独生成 source map 文件还是在行内显示，该参数在 eval- 参数存在时无效。 hidden：决定传入插件 append 的赋值，作用是判断是否添加 SourceMappingURL 的注释，该参数在 eval- 参数存在时无效。 module：为 true 时传入插件的 module 为 true ，作用是为加载器（Loaders）生成 source map。 cheap：这个关键字有两处作用。首先，当 module 为 false 时，它决定插件 module 参数的最终取值，最终取值与 cheap 相反。其次，它决定插件 columns 参数的取值，作用是决定生成的 source map 中是否包含列信息，在不包含列信息的情况下，调试时只能定位到指定代码所在的行而定位不到所在的列。 nosource：nosource 决定了插件中 noSource 变量的取值，作用是决定生成的 source map 中是否包含源代码信息，不包含源码情况下只能显示调用堆栈信息。 Source Map 处理插件从上面的规则中我们还可以看到，根据不同规则，实际上 Webpack 是从三种插件中选择其一作为 source map 的处理插件。 EvalDevToolModulePlugin：模块代码后添加 sourceURL=webpack:///+ 模块引用路径，不生成 source map 内容，模块产物代码通过 eval() 封装。 EvalSourceMapDevToolPlugin：生成 base64 格式的 source map 并附加在模块代码之后， source map 后添加 sourceURL=webpack:///+ 模块引用路径，不单独生成文件，模块产物代码通过 eval() 封装。 SourceMapDevToolPlugin：生成单独的 .map 文件，模块产物代码不通过 eval 封装。 通过上面的代码分析，我们了解了不同参数在 Webpack 运行时起到的作用。那么这些不同参数组合下的各种预设对我们的 source map 生成又各自会产生什么样的效果呢？ 不同预设的结果对比 devtool 类型 大小（KB）注 1 时间（ms）注 2 质量（代码可读性） 附加内容 调试效果 none 1553 3803/41（最快/最快） 打包后产物代码（地） - 无 eval 1597 3798/42（最快/最快） 生成后产物代码（低） 每个模块代码后添加 sourceURL=webpack:///./… 能定位到具体源文件名，但是现实内容为生成后代码，相比于 none 只是多了 eval()以及 sourceURL 指向 eval-source-map 5496 5915/89（最慢 ⬇/快） 源代码（最高 ⬆） 每个模块代码后添加 sourceURL=[module]\\n//#sourceMappingURL=…Base64 data 能定位到源文件名，且显示内容为源代码。点击调试点能定位到具体行与列 eval-cheap-source-map 3753 3862/64（快/更快） loader 处理后代码（中） 同上 能定位到源文件名，显示内容为经过 babel-loader 转换后的代码，点击调试能定位到行但缺少列信息，只能跳转到行首 eval-cheap-module-source-map 4023 4197/81（慢/更快） 缺少列信息的源代码（高） 同上 能定位到原文件名，切显示内容为源代码，点击调试能定位到行但缺少列信息，只能跳转到行首 source-map 1554/2836 5833/1721（最慢/最慢）⬇ 源代码（最高 ⬆） 单独生成.map 后缀的 sourcemap 文件，在产物代码末尾生成一个 sourceMappingURL=xxx.map 与 eval-source-map 效果相同 cheap-source-map 1554/1595 4099/122（快/慢） loader 转换后代码（中） 同上 与 eval-cheap-source-map 效果相同 cheap-module-source-map 1554/1794 4052/176（慢/更慢） 缺少列信息的源代码（高） 同上 与 eval-cheap-module-source-map 相同 inline-source-map 5336 5247/1543（最慢/最慢）⬇ 源代码（最高 ⬆） 在产物代码末尾生成一个 sourceMappingURL=…Base64 data 与 eval-source-map 相同，通常应用在第三方代码中 inline-cheap-source-map 3682 3785/131（快/慢） loader 转换后代码（中） 同上 与 eval-cheap-source-map 效果相同 inline-cheap-module-source-map 3947 4146/185（慢/更慢） 缺少列信息的源代码（高） 同上 与 eval-cheap-module-source-map 相同 hidden-source-map 1554/2836 5871/1569（最慢/最慢）⬇ 源代码（最高 ⬆） 单独生成.map 后缀的 sourcemap 文件，产物代码末尾不添加 sourceMappingURL，即起到隐藏的作用，通常用于错误报告工具中定位使用 外部访问不带 sourceMappingURL 的产物文件，而生成的 sourcemap 文件仅用于错误报告工具等特殊情况下生成和使用，通常不上传到 web 服务器中 nosources-source-map 1554/1173 5270/1568（最慢/最慢）⬇ 无法显示代码（最低 ⬇） 与 source-map 相同 用于在报错信息上传于调试时显示堆栈信息，而无法查看源码 *注 1：“/”前后分别表示产物 js 大小和对应 .map 大小。*注 2：“/”前后分别表示初次构建时间和开启 watch 模式下 rebuild 时间。对应统计的都是 development 模式下的笔者机器环境下几次构建时间的平均值，只作为相对快慢与量级的比较。 选择不同的devtool会产生不同的效果 质量：souce-map = eval-source-map &gt; cheap-module- &gt; cheap- &gt; eval = none &gt; nosource- 构建速度：再次构建速度都大于第一次构建速度 在开发环境下：一直开着 devServer，再次构建的速度对我们的效率影响远大于初次构建的速度。从结果中可以看到，eval- 对应的 EvalSourceMapDevToolPlugin 整体要快于不带 eval- 的 SourceMapDevToolPlugin。尤其在质量最佳的配置下，eval-source-map 的再次构建速度要远快于其他几种。而同样插件配置下，不同质量配置与构建速度成反比，但差异程度有限，更多是看具体项目的大小而定。 在生产环境下：通常不会开启再次构建，因此相比再次构建，初次构建的速度更值得关注，甚至对构建速度以外因素的考虑要优先于对构建速度的考虑。 包的大小和生成方式：在开发环境下我们并不需要关注这些因素，正如开发环境下也通常不考虑使用分包等优化方式。我们需要关注速度和质量来保证我们的开发体验。 开发环境下Source Map推荐预设 如果在调试时，需要通过source map来快速定位源代码，优先考虑使用eval-cheap-module-source-map 或者使用eval-source-map eval-cheap-source-map 或者通过EvalSourceMapDevToolPlugin EvalDevToolModulePlugin插件 reference👍浏览器工具是如何将 source map 内容映射回源文件 在控制台的网络面板中通常看不到 source map 文件的请求，其原因是出于安全考虑 Chrome 隐藏了 source map 的请求，需要通过 net-log 来查询。 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/%E4%BB%80%E4%B9%88%E6%98%AFsource-map/"},{"title":"Window Terminal美化💖","text":"Window Terminal终端程序是一款新式、快速、高效、强大且高效的终端应用程序，适用于命令行工具和命令提示符，PowerShell和WSL等Shell用户。主要功能包括多个选项卡、窗格、Unicode、和UTF-8字符支持，GPU加速文本渲染引擎以及自定义主题、样式和配置。 安装Window Terminal安装Window Terminal，通过Microsoft Store商店安装即可，安装Window Terminal对系统有一定的要求。系统版本必须为Windows 10版本 18362.0或更好的版本，必须为x86 ARM64 x64体系结构。Window Terminal是一个开源项目，地址 配置字体这里我使用的事Fira Code字体，地址 配置主题这里我使用的是posh-git、on-my-posh主题。安装，使用window powerShell 最好使用管理员权限 window powerShell12Install-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser 配置和切换主题 window powerShell1234$PROFILEif (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }notepad $PROFILE 也可直接使用命令$PROFILE，会输出默认配置文件的地址，一般会在C盘 在打开的文件中添加，这样配置的是默认的主题 ps1123Import-Module posh-gitImport-Module oh-my-poshSet-Theme Sorin 切换主题 Git Bash/Shell/Terminal1Set-Theme ${主题名字} 以下是可用的主题名字：Agnoster、Avit、Darkblood、Fish、Honukai、Paradox、Sorin、tehrob 配置Window Terminal打开设置 添加defaults和schemes 点击展开代码 &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\"defaults\": { // Put settings here that you want to apply to all profiles. \"fontFace\": \"Fira Code\", // oh-my-posh 主题原因，使用其他的字体可能会出现乱码 \"backgroundImage\": \"F:\\\\vscodeBg\\\\014.jpg\", // 背景图片地址 \"backgroundImageOpacity\": 0.4, // 透明度 \"colorScheme\": \"Andromeda\", // 颜色方案 \"acrylicOpacity\": 0.7, \"useAcrylic\": true},\"schemes\": [ { \"name\": \"Andromeda\", \"black\": \"#000000\", \"red\": \"#cd3131\", \"green\": \"#05bc79\", \"yellow\": \"#09da0f\", // \"yellow\": \"#e5e512\", \"blue\": \"#2472c8\", \"purple\": \"#bc3fbc\", \"cyan\": \"#0fa8cd\", \"white\": \"#e5e5e5\", \"brightBlack\": \"#666666\", \"brightRed\": \"#cd3131\", \"brightGreen\": \"#05bc79\", \"brightYellow\": \"#09da0f\", // \"brightYellow\": \"#e5e512\", \"brightBlue\": \"#2472c8\", \"brightPurple\": \"#bc3fbc\", \"brightCyan\": \"#0fa8cd\", \"brightWhite\": \"#e5e5e5\", \"background\": \"#262a33\", \"foreground\": \"#e5e5e5\" }, { \"name\": \"Campbell\", \"foreground\": \"#F2F2F2\", \"background\": \"#0C0C0C\", \"colors\": [ \"#0C0C0C\", \"#C50F1F\", \"#13A10E\", \"#C19C00\", \"#0037DA\", \"#881798\", \"#3A96DD\", \"#CCCCCC\", \"#767676\", \"#E74856\", \"#16C60C\", \"#F9F1A5\", \"#3B78FF\", \"#B4009E\", \"#61D6D6\", \"#F2F2F2\" ] }, { \"name\": \"Solarized Dark\", \"foreground\": \"#FDF6E3\", \"background\": \"#073642\", \"colors\": [ \"#073642\", \"#D30102\", \"#859900\", \"#B58900\", \"#268BD2\", \"#D33682\", \"#2AA198\", \"#EEE8D5\", \"#002B36\", \"#CB4B16\", \"#586E75\", \"#657B83\", \"#839496\", \"#6C71C4\", \"#93A1A1\", \"#FDF6E3\" ] } ] 官方配置详解 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Configuration/window-terminal%E7%BE%8E%E5%8C%96%F0%9F%92%96/"},{"title":"Icarus指南","text":"Icarus的默认主题配置文件为_config.icarus.yml。此文件定义了站点全局的布局与样式设置，同时也控制了例如插件与挂件等外部功能的配置。本文详细介绍了主题的一般配置，并且解释了Icarus使用哪些配置文件和它是如何生成并验证这些配置。 配置基础属性_config.icarus.yml12345678910111213141516version: 4.0.0 // 版本号variant: default // 皮肤，目前支持default和cyberpunklogo: /img/logo.svg 或者logo: text: My Beautiful Sitehead: favicon: /img/favicon.svgarticle: // 代码高亮 highlight: # 代码高亮主题 # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # 显示复制代码按钮 clipboard: true # 代码块的默认折叠状态。可以是\"\", \"folded\", \"unfolded\" fold: unfolded 折叠代码块 123{% codeblock \"可选文件名\" lang:代码语言 &gt;folded %}...代码块内容...{% endcodeblock %} 文章配置_config.icarus.yml123456789101112131415161718title: Icarus指南 // 标题date: 2020-09-22 // 创建时间tags: // 标签- Icarus指南categories: // 分类- HexoThemelanguage: zh-CN // 语言toc: true // 是否生成目录providers: // 使用cnd地址 cdn: loli fontcdn: loli iconcdn: lolicover: /gallery/covers/beautiful-landscape.svg // 封面图thumbnail: /gallery/covers/beautiful-landscape.svg // 缩略图comment: // 评论search: // 搜索share: // 转发widgets: // 挂件 按钮 Info Success Warning Danger 点击展开代码123456&lt;div class=\"buttons\"&gt; &lt;button class=\"button is-info\"&gt;Info&lt;/button&gt; &lt;button class=\"button is-success\"&gt;Success&lt;/button&gt; &lt;button class=\"button is-warning\"&gt;Warning&lt;/button&gt; &lt;button class=\"button is-danger\"&gt;Danger&lt;/button&gt;&lt;/div&gt; 显示一言增加了一个单击事件 显示一言 ↑↑↑ 试着点击“显示一言”！ function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } }); } 点击展开代码12345678910111213141516&lt;button class=\"button is-info\" onclick=\"showHitokoto(event)\"&gt;显示一言&lt;/button&gt;&lt;blockquote class=\"hitokoto\"&gt;↑↑↑ 试着点击“显示一言”！&lt;/blockquote&gt;&lt;script&gt;function showHitokoto (event) { event.target.classList.add('is-loading'); $.ajax({ type: 'GET', url: 'https://v1.hitokoto.cn/', success: function (data) { $('.hitokoto').text(data.hitokoto); event.target.classList.remove('is-loading'); } });}&lt;/script&gt; 进度条 点击展开代码12345&lt;progress class=\"progress is-info\" value=\"20\" max=\"100\"&gt;&lt;/progress&gt;&lt;progress class=\"progress is-success\" value=\"40\" max=\"100\"&gt;&lt;/progress&gt;&lt;progress class=\"progress is-warning\" value=\"60\" max=\"100\"&gt;&lt;/progress&gt;&lt;progress class=\"progress is-danger\" value=\"80\" max=\"100\"&gt;&lt;/progress&gt;&lt;progress class=\"progress is-info\" max=\"100\"&gt;&lt;/progress&gt; 标签页 Pictures Music Videos Pixabay 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材… 网易云音乐 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。 哔哩哔哩 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。 .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); } 点击展开代码 &gt;folded123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=\"tabs is-toggle\"&gt;&lt;ul&gt;&lt;li class=\"is-active\"&gt;&lt;a onclick=\"onTabClick(event)\"&gt;&lt;span class=\"icon is-small\"&gt;&lt;i class=\"fas fa-image\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Pictures&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=\"onTabClick(event)\"&gt;&lt;span class=\"icon is-small\"&gt;&lt;i class=\"fas fa-music\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Music&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=\"onTabClick(event)\"&gt;&lt;span class=\"icon is-small\"&gt;&lt;i class=\"fas fa-film\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt;&lt;span&gt;Videos&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div id=\"Pictures\" class=\"tab-content\" style=\"display: block;\"&gt;[Pixabay](https://pixabay.com/zh/) 是全球知名的图库网站及充满活力的创意社区,拥有上百万张免费正版高清照片素材,涵盖风景、人物、动态、静物等多种分类,你可以在任何地方使用 Pixabay 图库中的素材...&lt;/div&gt;&lt;div id=\"Music\" class=\"tab-content\"&gt;[网易云音乐](https://music.163.com/) 是一款专注于发现与分享的音乐产品,依托专业音乐人、DJ、好友推荐及社交功能,为用户打造全新的音乐生活。&lt;/div&gt;&lt;div id=\"Videos\" class=\"tab-content\"&gt;[哔哩哔哩](https://www.bilibili.com/) 是国内知名的视频弹幕网站,这里有最及时的动漫新番,最棒的ACG氛围,最有创意的Up主。大家可以在这里找到许多欢乐。&lt;/div&gt;&lt;style type=\"text/css\"&gt;.content .tabs ul { margin: 0; }.tab-content { display: none; }&lt;/style&gt;&lt;script&gt;function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active');}&lt;/script&gt; 或者 点击展开代码 &gt;folded12345678910111213141516171819202122232425262728293031&lt;div class=\"tabs is-boxed my-3\"&gt; &lt;ul class=\"mx-0 my-0\"&gt; &lt;li class=\"is-active\"&gt; &lt;a href=\"#install-source\"&gt; &lt;span class=\"icon is-small\"&gt;&lt;i class=\"fas fa-file-code\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;从源码安装&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#install-npm\"&gt; &lt;span class=\"icon is-small\"&gt;&lt;i class=\"fas fa-cubes\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;span&gt;使用NPM安装&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div id=\"install-source\" class=\"tab-content\"&gt; 从GitHub的仓库中下载源码的压缩包并解压到你Hexo站点的主题目录中。 或者，你可以使用Git来克隆Icarus的代码仓库到`themes`目录下： &lt;figure class=\"highlight plain\"&gt;&lt;figcaption&gt;&lt;span&gt;Git Bash/命令行&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=\"gutter\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=\"code\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;ppoffice&amp;#x2F;hexo-theme-icarus.git themes&amp;#x2F;icarus -b &amp;lt;version number&amp;gt; --depth 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt; 你可以省略&lt;code&gt;-b &amp;lt;version number&amp;gt;&lt;/code&gt;来获取Icarus的最新开发版本。&lt;br&gt; 如果你想同时下载Git仓库的完整提交历史，请同时省略&lt;code&gt;--depth 1&lt;/code&gt;。&lt;br&gt; 另外，你也可以使用下面的命令将Icarus安装为Git子模块(submodule)：&lt;/p&gt; &lt;figure class=\"highlight plain\"&gt;&lt;figcaption&gt;&lt;span&gt;Git Bash/命令行&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=\"gutter\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=\"code\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;git submodule add https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;ppoffice&amp;#x2F;hexo-theme-icarus.git themes&amp;#x2F;icarus&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;&lt;div id=\"install-npm\" class=\"tab-content is-hidden\"&gt; 若要使用NPM将Icarus安装为Node包，在你的Hexo站点根目录运行如下命令： &lt;figure class=\"highlight plain\"&gt;&lt;figcaption&gt;&lt;span&gt;命令行&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=\"gutter\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=\"code\"&gt;&lt;pre&gt;&lt;span class=\"line\"&gt;npm install -S hexo-theme-icarus&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt; 彩色突出 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 活用 Bulma 美化 Icarus 文章 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。 点击展开代码 &gt;folded1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=\"notification is-info\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;div class=\"notification is-success\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;div class=\"notification is-warning\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;div class=\"notification is-danger\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;article class=\"message is-info\"&gt;&lt;div class=\"message-body\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;/article&gt;&lt;article class=\"message is-success\"&gt;&lt;div class=\"message-body\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;/article&gt;&lt;article class=\"message is-warning\"&gt;&lt;div class=\"message-body\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;/article&gt;&lt;article class=\"message is-danger\"&gt;&lt;div class=\"message-body\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;/article&gt;&lt;article class=\"message is-info\"&gt;&lt;div class=\"message-header\"&gt;活用 Bulma 美化 Icarus 文章&lt;/div&gt;&lt;div class=\"message-body\"&gt;[Icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/) 主题以白色的简洁为主，但有时候我们希望在文章中用**特别的样式**注明一些内容，*markdown* 语法就不够用了，所以在此分享一下我的高级玩法。&lt;/div&gt;&lt;/article&gt; 颜色遮罩(你知道的太多了) .heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } .heimu-red { color: red; background-color: red; } .heimu-red:hover { color: #fff; } 我在这里 我在这里 点击展开代码 &gt;folded12345678910&lt;style type=\"text/css\"&gt;.heimu { color: #000; background-color: #000; }.heimu:hover { color: #fff; }.heimu-red { color: red; background-color: red; }.heimu-red:hover { color: #fff; }&lt;/style&gt;&lt;span class=\"heimu\"&gt;我在这里&lt;/span&gt; 封面图来源声明 &nbsp;&nbsp; Vector Landscape Vectors by Vecteezy 点击展开代码1234&lt;a class=\"tag is-dark is-medium\" href=\"https://www.vecteezy.com/free-vector/vector-landscape\" target=\"_blank\"&gt;&lt;span class=\"icon\"&gt;&lt;i class=\"fas fa-camera\"&gt;&lt;/i&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;Vector Landscape Vectors by Vecteezy&lt;/a&gt; 官方提供的配置文档 活用 Bulma 美化 Icarus 文章 by iMaeGoo Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Hexo/icarus%E6%8C%87%E5%8D%97/"},{"title":"React基础","text":"基于create-react-app进行React学习，React个人感觉与Vue最大的区别在于高复用性，每一个组件都只做一件事，组件的业务逻辑可以放在父级去做(状态提升)。这与Vue2.0相差甚大，不过随着Vue3.0的到来，Vue也完全可以采取这种方式。弊端是React采用jsx、tsx进行DOM书写，需要额外学习一下语法糖，不过都是小问题🙁 example地址 Props StateReact为向下数据流(因此我们可以将父组件的state传递到子组件)，因此可以状态提升(状态提升就是把子组件的state提升到父组件) Props 用来父子间传递数据，function下可直接 (props) =&gt; props[key] || props.”key”，class下需要this.props[key] || this.props.”key” State 不要直接修改State，修改State最好使用setState()进行修改，否则页面可能不会刷新 State的更新可能是异步的，React出于性能考虑，会把多个setState合并为一个调用，因此State更新可能是异步的，如何让其能快速更新到dom呢？ State State的更新会被合并 列表 key 类似Vue v-for keyFragments 类似Vue Template React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。 使用 123456789render() { return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; );} 短语法不支持key属性 12345678910class Columns extends React.Component { render() { return ( &lt;&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/&gt; ); }} Fragments React.lazyReact lazy 像渲染常规组件一样处理动态引入的(组件) 123456789101112import React, { Suspense } from 'React'const OntherComponent = React.lazy(() =&gt; import('./OtherComponent'))function MyComponent() { return ( &lt;div&gt; &lt;Suspense fallback={ &lt;div&gt;Loading...&lt;/div&gt; }&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; )} React.createContext类似Vue中的provide inject吧，但是React中就没有那么好用了…，如果在不需要监听器变化的情况下，声明外部变量感觉更好用一点。 文档地址 错误辩解 Error BoundariesReact16之后引入，目的是捕获并打印发生在其子组件树任何位置的JavaScript错误，并且，渲染备用UI 文档链接 无法捕获时间处理、异步代码、服务端渲染以及其自身抛出的错误 如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。 ErrorBoundary 12345678910111213141516171819202122232425class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // 更新 state 使下一次渲染能够显示降级后的 UI return { hasError: true }; } componentDidCatch(error, errorInfo) { // 你同样可以将错误日志上报给服务器 logErrorToMyService(error, errorInfo); } render() { if (this.state.hasError) { // 你可以自定义降级后的 UI 并渲染 return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; } return this.props.children; }} Refs🙁感觉不会经常用到 HOC 高阶组件🙁 不要在render中使用 Refs不会被传递 JSX组件名大写 JSX不能是一个表达式 Boolean、Null、Undefined将被忽略不会渲染 12345678910111213141516171819202122function Story(props) { // 错误！JSX 类型不能是一个表达式。 return &lt;components[props.storyType] story={props.story} /&gt;;}function Story(props) { // 正确！JSX 类型可以是大写字母开头的变量。 const SpecificStory = components[props.storyType]; return &lt;SpecificStory story={props.story} /&gt;;}&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;{false}&lt;/div&gt;&lt;div&gt;{null}&lt;/div&gt;&lt;div&gt;{undefined}&lt;/div&gt;&lt;div&gt;{true}&lt;/div&gt; PortalsPortal提供了一种将子节点渲染到父节点以外的DOM节点的方案 1234567891011ReactDOM.createPortal(child, container) // 语法// examplerender() { // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。 // `domNode` 是一个可以在任何位置的有效 DOM 节点。 return ReactDOM.createPortal( this.props.children, domNode );} child是任何可渲染的React子元素，container是一个DOM元素 ProfilerProfiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，只能应用于开发环境 React Profiler StrictMode严格模式，只能应用于开发环境 React StrictMode React 生命周期React 生命周期 react-lifecycle-methods-diagram 挂载 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下： constructor() static getDerivedStateFromProps() render() componentDidMount() 更新 当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 卸载当组件从 DOM 中移除时会调用如下方法： componentWillUnmount() 错误处理当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法： static getDerivedStateFromError() componentDidCatch() 其他 APIs组件还提供了一些额外的 API： setState() forceUpdate() class 属性 defaultProps displayName 实例属性 props state ReactDOM render 渲染元素 hydrate 与render相同 unmountComponentAtNode 从DOM中卸载组件，会一并清除state findDOMNode 如果组件已经被渲染在DOM上，返回响应的原生DOM元素 findDOMNode 创建portal Portal提供了一种将子节点渲染到父节点以外的DOM节点的方案 ReactDOM ReactDOMServerReactDOMServer 对象允许你将组件渲染成静态标记。通常，它被使用在 Node 服务端上 DOMdangerouslySetInnerHTML dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。通常来讲，使用代码直接设置 HTML 存在风险，因为很容易无意中使用户暴露于跨站脚本（XSS）的攻击。因此，你可以直接在 React 中设置 HTML，但当你想设置 dangerouslySetInnerHTML 时，需要向其传递包含 key 为 __html 的对象，以此来警示你。例如： 1234567function createMarkup() { return {__html: 'First &amp;middot; Second'};}function MyComponent() { return &lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;;} htmlFor 由于 for 在 JavaScript 中是保留字，所以 React 元素中使用了 htmlFor 来代替。 suppressContentEditableWarning 通常，当拥有子节点的元素被标记为 contentEditable 时，React 会发出一个警告，因为这不会生效。该属性将禁止此警告。尽量不要使用该属性，除非你要构建一个类似 Draft.js 的手动管理 contentEditable 属性的库。 suppressHydrationWarning 如果你使用 React 服务端渲染，通常会在当服务端与客户端渲染不同的内容时发出警告。但是，在一些极少数的情况下，很难甚至于不可能保证内容的一致性。例如，在服务端和客户端上，时间戳通常是不同的。如果设置 suppressHydrationWarning 为 true，React 将不会警告你属性与元素内容不一致。它只会对元素一级深度有效，并且打算作为应急方案。因此不要过度使用它。你可以在 ReactDOM.hydrate() 文档 中了解更多关于 hydration 的信息 React采用小驼峰式命名，多DOM的支持有 12345678910111213accept acceptCharset accessKey action allowFullScreen alt async autoCompleteautoFocus autoPlay capture cellPadding cellSpacing challenge charSet checkedcite classID className colSpan cols content contentEditable contextMenu controlscontrolsList coords crossOrigin data dateTime default defer dir disableddownload draggable encType form formAction formEncType formMethod formNoValidateformTarget frameBorder headers height hidden high href hrefLang htmlForhttpEquiv icon id inputMode integrity is keyParams keyType kind label lang listloop low manifest marginHeight marginWidth max maxLength media mediaGroup methodmin minLength multiple muted name noValidate nonce open optimum patternplaceholder poster preload profile radioGroup readOnly rel required reversedrole rowSpan rows sandbox scope scoped scrolling seamless selected shape sizesizes span spellCheck src srcDoc srcLang srcSet start step style summarytabIndex target title type useMap value width wmode wrap 合成事件SyntheticEvent 实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。 合成事件 Hook 简介在Function中使用一些Class中拥有的属性 每个组件间的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，它不复用 state 本身。事实上 Hook 的每次调用都有一个完全独立的 state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 Hook 简介 Hook Api索引 Hook 概览useStateState Hook useState 1234567891011121314import React, { useState } from 'react';function Example() { // 声明一个叫 “count” 的 state 变量。 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 惰性初始state initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用 12345const [state, setState] = useState(() =&gt; { const initialState = someExpensiveComputation(props); return initialState;}); useEffectuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。（我们会在使用 Effect Hook 里展示对比 useEffect 和这些方法的例子。） Effect Hook useEffect 1234567891011121314151617181920import React, { useState, useEffect } from 'react';function Example() { const [count, setCount] = useState(0); // 相当于 componentDidMount 和 componentDidUpdate: useEffect(() =&gt; { // 使用浏览器的 API 更新页面标题 document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 第二个参数 effect所依赖的数值，只有当这个值变化时才会更新 1234567891011useEffect( () =&gt; { const subscription = props.source.subscribe(); return () =&gt; { subscription.unsubscribe(); }; }, [props.source],);useEffect(..., []) // 这将只在组件挂载和卸载时执行 useContextuseContext 让你不使用组件嵌套就可以订阅 React 的 Context。 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定 useContext 12345678910111213141516171819202122232425262728293031323334353637const themes = { light: { foreground: \"#000000\", background: \"#eeeeee\" }, dark: { foreground: \"#ffffff\", background: \"#222222\" }};const ThemeContext = React.createContext(themes.light);function App() { return ( &lt;ThemeContext.Provider value={themes.dark}&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );}function Toolbar(props) { return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );}function ThemedButton() { const theme = useContext(ThemeContext); return ( &lt;button style={{ background: theme.background, color: theme.foreground }}&gt; I am styled by theme context! &lt;/button&gt; );} useReduceruseReducer 可以让你通过 reducer 来管理组件本地的复杂 state useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 useReducer useCallbackuseCallback useMemouseMemo useRefuseRef useImperativeHandleuseImperativeHandle useLayoutEffectuseLayoutEffect useDebugValueuseDebugValue Hook使用规则 只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用 只能在React的函数组件中调用Hook。不要在其他JavaScript函数中调用。 Hook 使用规则 Hook 规则 Something wrong with this article? Click here to submit your revision. Vector Landscape Vectors by Vecteezy document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Front/react%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Network Request","slug":"Network-Request","link":"/tags/Network-Request/"},{"name":"Chocolatey","slug":"Chocolatey","link":"/tags/Chocolatey/"},{"name":"commitizen","slug":"commitizen","link":"/tags/commitizen/"},{"name":"Browser","slug":"Browser","link":"/tags/Browser/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"Git操作指南","slug":"Git操作指南","link":"/tags/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"},{"name":"nrm","slug":"nrm","link":"/tags/nrm/"},{"name":"nvm","slug":"nvm","link":"/tags/nvm/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"Hexo-Theme","slug":"Hexo-Theme","link":"/tags/Hexo-Theme/"},{"name":"Icarus指南","slug":"Icarus指南","link":"/tags/Icarus%E6%8C%87%E5%8D%97/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"Css","slug":"Css","link":"/categories/Css/"},{"name":"Configuration","slug":"Configuration","link":"/categories/Configuration/"},{"name":"Front","slug":"Front","link":"/categories/Front/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"FAQ","slug":"FAQ","link":"/categories/FAQ/"},{"name":"Learning","slug":"Learning","link":"/categories/Learning/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"}]}